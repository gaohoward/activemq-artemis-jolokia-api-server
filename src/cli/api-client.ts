// Auto-generated by https://github.com/vladkens/apigen-ts
// Source: src/config/openapi.yml

export interface ApigenConfig {
  baseUrl: string;
  headers: Record<string, string>;
}

export interface ApigenRequest extends Omit<RequestInit, 'body'> {
  search?: Record<string, unknown>;
  body?: unknown;
}

export class ApiClient {
  Config: ApigenConfig;

  constructor(config?: Partial<ApigenConfig>) {
    this.Config = { baseUrl: '/', headers: {}, ...config };
  }

  async ParseError(rep: Response) {
    try {
      return await rep.json();
    } catch (e) {
      throw rep;
    }
  }

  PrepareFetchUrl(path: string): URL {
    let base = this.Config.baseUrl;
    if ('location' in globalThis && (base === '' || base.startsWith('/'))) {
      const { location } = globalThis as unknown as {
        location: { origin: string };
      };
      base = `${location.origin}${base.endsWith('/') ? base : `/${base}`}`;
    }

    return new URL(path, base);
  }

  async Fetch<T>(
    method: string,
    path: string,
    opts: ApigenRequest = {},
  ): Promise<T> {
    const url = this.PrepareFetchUrl(path);

    for (const [k, v] of Object.entries(opts?.search ?? {})) {
      url.searchParams.append(
        k,
        Array.isArray(v) ? v.join(',') : (v as string),
      );
    }

    const headers = new Headers({ ...this.Config.headers, ...opts.headers });
    const ct = headers.get('content-type') ?? 'application/json';

    let body: FormData | URLSearchParams | string | undefined = undefined;

    if (
      ct === 'multipart/form-data' ||
      ct === 'application/x-www-form-urlencoded'
    ) {
      headers.delete('content-type');
      body =
        ct === 'multipart/form-data' ? new FormData() : new URLSearchParams();
      for (const [k, v] of Object.entries(
        opts.body as Record<string, string>,
      )) {
        body.append(k, v);
      }
    }

    if (ct === 'application/json' && typeof opts.body !== 'string') {
      headers.set('content-type', 'application/json');
      body = JSON.stringify(opts.body);
    }

    const credentials = opts.credentials ?? 'include';
    const rep = await fetch(url.toString(), {
      method,
      ...opts,
      headers,
      body,
      credentials,
    });
    if (!rep.ok) throw await this.ParseError(rep);

    const rs = await rep.text();
    try {
      return JSON.parse(rs) as T;
    } catch (e) {
      return rs as unknown as T;
    }
  }

  security = {
    serverLogin: (body: { userName: string; password: string }) => {
      return this.Fetch<ServerLoginResponse>('post', '/server/login', { body });
    },

    serverLogout: (body: EmptyBody) => {
      return this.Fetch<ServerLogoutResponse>('post', '/server/logout', {
        body,
      });
    },

    login: (body: {
      brokerName: string;
      userName: string;
      password: string;
      jolokiaHost: string;
      scheme: string;
      port: string;
    }) => {
      return this.Fetch<LoginResponse>('post', '/jolokia/login', { body });
    },
  };

  admin = {
    listEndpoints: () => {
      return this.Fetch<Endpoint[]>('get', '/server/admin/listEndpoints', {});
    },
  };

  jolokia = {
    getBrokers: (search: { targetEndpoint?: string }) => {
      return this.Fetch<Broker[]>('get', '/brokers', { search });
    },

    getBrokerDetails: (search: { targetEndpoint?: string }) => {
      return this.Fetch<ComponentDetails>('get', '/brokerDetails', { search });
    },

    readBrokerAttributes: (search: {
      names?: string[];
      targetEndpoint?: string;
    }) => {
      return this.Fetch<ComponentAttribute[]>('get', '/readBrokerAttributes', {
        search,
      });
    },

    readAddressAttributes: (search: {
      name?: string;
      attrs?: string[];
      targetEndpoint?: string;
    }) => {
      return this.Fetch<ComponentAttribute[]>('get', '/readAddressAttributes', {
        search,
      });
    },

    readQueueAttributes: (search: {
      name?: string;
      address?: string;
      'routing-type'?: string;
      attrs?: string[];
      targetEndpoint?: string;
    }) => {
      return this.Fetch<ComponentAttribute[]>('get', '/readQueueAttributes', {
        search,
      });
    },

    readAcceptorAttributes: (search: {
      name?: string;
      attrs?: string[];
      targetEndpoint?: string;
    }) => {
      return this.Fetch<ComponentAttribute[]>(
        'get',
        '/readAcceptorAttributes',
        { search },
      );
    },

    readClusterConnectionAttributes: (search: {
      name?: string;
      attrs?: string[];
      targetEndpoint?: string;
    }) => {
      return this.Fetch<ComponentAttribute[]>(
        'get',
        '/readClusterConnectionAttributes',
        { search },
      );
    },

    execClusterConnectionOperation: (
      body: OperationRef,
      search: {
        name?: string;
        targetEndpoint?: string;
      },
    ) => {
      return this.Fetch<ExecResult[]>(
        'post',
        '/execClusterConnectionOperation',
        { search, body },
      );
    },

    checkCredentials: () => {
      return this.Fetch<DummyResponse>('get', '/checkCredentials', {});
    },

    execBrokerOperation: (
      body: OperationRef,
      search: {
        targetEndpoint?: string;
      },
    ) => {
      return this.Fetch<ExecResult[]>('post', '/execBrokerOperation', {
        search,
        body,
      });
    },

    getBrokerComponents: (search: { targetEndpoint?: string }) => {
      return this.Fetch<string[]>('get', '/brokerComponents', { search });
    },

    getAddresses: (search: { targetEndpoint?: string }) => {
      return this.Fetch<Address[]>('get', '/addresses', { search });
    },

    getQueues: (search: { address?: string; targetEndpoint?: string }) => {
      return this.Fetch<Queue[]>('get', '/queues', { search });
    },

    getQueueDetails: (search: {
      addressName?: string;
      name?: string;
      routingType?: string;
      targetEndpoint?: string;
    }) => {
      return this.Fetch<ComponentDetails>('get', '/queueDetails', { search });
    },

    getAddressDetails: (search: { name?: string; targetEndpoint?: string }) => {
      return this.Fetch<ComponentDetails>('get', '/addressDetails', { search });
    },

    getAcceptors: (search: { targetEndpoint?: string }) => {
      return this.Fetch<Acceptor[]>('get', '/acceptors', { search });
    },

    getAcceptorDetails: (search: {
      name?: string;
      targetEndpoint?: string;
    }) => {
      return this.Fetch<ComponentDetails>('get', '/acceptorDetails', {
        search,
      });
    },

    getClusterConnections: (search: { targetEndpoint?: string }) => {
      return this.Fetch<ClusterConnection[]>('get', '/clusterConnections', {
        search,
      });
    },

    getClusterConnectionDetails: (search: {
      name?: string;
      targetEndpoint?: string;
    }) => {
      return this.Fetch<ComponentDetails>('get', '/clusterConnectionDetails', {
        search,
      });
    },
  };

  development = {
    apiInfo: () => {
      return this.Fetch<ApiResponse>('get', '/api-info', {});
    },
  };
}

export type Acceptor = {
  name: string;
  broker: Broker;
};

export type Address = {
  name: string;
  broker: Broker;
};

export type ApiResponse = {
  message?: {
    security?: {
      enabled?: boolean;
    };
    info?: {
      name?: string;
      description?: string;
      version?: string;
    };
    paths?: {
      post?: string[];
      get?: string[];
    };
  };
  status?: 'successful';
  'jolokia-session-id'?: string;
};

export type Argument = {
  name: string;
  type: JavaTypes;
  desc: string;
};

export type Attr = {
  desc: string;
  rw: boolean;
  type: JavaTypes;
};

export type Broker = {
  name: string;
};

export type ClusterConnection = {
  name: string;
  broker: Broker;
};

export type ComponentAttribute = {
  request: {
    mbean: string;
    attribute?: string;
    type: string;
  };
  value?: unknown;
  error_type?: string;
  error?: string;
  timestamp?: number;
  status: number;
};

export type ComponentDetails = {
  op: object;
  attr: object;
  class: string;
  desc: string;
};

export type DummyResponse = {
  message: 'ok';
  status: 'successful';
};

export type EmptyBody = object | null;

export type Endpoint = {
  name: string;
  url?: string;
};

export type ExecResult = {
  request: {
    mbean: string;
    arguments: string[];
    type: string;
    operation: string;
  };
  value?: unknown;
  error_type?: string;
  error?: string;
  timestamp?: number;
  status: number;
};

export type FailureResponse = {
  status: 'failed' | 'error';
  message: string;
};

export enum JavaTypes {
  _Ljava_lang_Object_ = '[Ljava.lang.Object;',
  _Ljava_lang_String_ = '[Ljava.lang.String;',
  _Ljava_util_Map_ = '[Ljava.util.Map;',
  _Ljavax_management_openmbean_CompositeData_ = '[Ljavax.management.openmbean.CompositeData;',
  Object = 'Object',
  Boolean = 'boolean',
  Double = 'double',
  Int = 'int',
  Java_lang_Boolean = 'java.lang.Boolean',
  Java_lang_Integer = 'java.lang.Integer',
  Java_lang_Long = 'java.lang.Long',
  Java_lang_Object = 'java.lang.Object',
  Java_lang_String = 'java.lang.String',
  Java_util_Map = 'java.util.Map',
  Long = 'long',
  Void = 'void',
}

export type LoginResponse = {
  message: string;
  status: string;
  'jolokia-session-id': string;
};

export type OperationArgument = {
  type: JavaTypes;
  value: string;
};

export type OperationRef = {
  signature: {
    name: string;
    args: OperationArgument[];
  };
};

export type OperationResult = {
  request: {
    mbean: string;
    arguments: string[];
    type: string;
    operation: string;
  };
  value: string;
  timestamp: number;
  status: number;
};

export type Queue = {
  name: string;
  'routing-type': string;
  address?: Address;
  broker: Broker;
};

export type ServerLoginResponse = {
  message: string;
  status: string;
  bearerToken: string;
};

export type ServerLogoutResponse = {
  message: string;
  status: string;
};

export type Signature = {
  ret?: JavaTypes;
  desc: string;
  args: Argument[];
};

export type Signatures = Signature[];
